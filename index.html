<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minecraft Bedrock Playsound List</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Noto Color Emoji, sans-serif; }
    header { position: sticky; top:0; backdrop-filter: blur(6px); padding: 10px 16px; border-bottom: 1px solid #0003; display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    header h1 { margin: 0 12px 0 0; font-size: 18px; }
    header .meta { font-size: 13px; opacity: .8; }
    #controls { margin-left:auto; display:flex; gap:8px; align-items:center; }
    #search { padding:8px 10px; border:1px solid #0003; border-radius:8px; min-width:220px; }
    #list { padding: 16px; display: grid; grid-template-columns: repeat(auto-fit, minmax(260px,1fr)); gap: 12px; }
    .card { border:1px solid #0003; border-radius: 12px; padding: 12px; display:flex; flex-direction:column; gap:10px; }
    .title { font-weight: 600; font-size: 14px; word-break: break-all; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding:8px 12px; border-radius:10px; border:1px solid #0003; cursor:pointer; }
    .small { font-size:12px; opacity:.75; }
    .pagination { display:flex; gap:6px; padding: 10px 16px 20px; align-items:center; flex-wrap:wrap; }
    .pagination button[disabled] { opacity:.4; cursor: default; }
    .range { width: 160px; }
    footer { padding: 16px; font-size:12px; opacity:.65; text-align:center; }
  </style>
</head>
<body>
  <header>
    <h1>Playsound 리스트</h1>
    <div class="meta"><span id="count">—</span></div>
    <div id="controls">
      <input id="search" type="search" placeholder="이벤트 이름 검색 (예: beacon.power, block.mud.hit)" />
      <span class="small">페이지당 100개</span>
    </div>
  </header>

  <div id="list"></div>
  <div class="pagination" id="pager"></div>
  <footer>Bedrock sound_definitions 기반 • 변종 파일(1,2,3…)은 한 항목으로 묶여 랜덤 재생</footer>

  <script>
  // ====== 설정 ======
  const PAGE_SIZE = 100;
  // sound_definitions 파일(.json 권장, .txt도 지원)
  const DEF_URLS = ["sound_definitions.json", "sound_definitions.txt"];
  // 실제 wav 파일의 루트(prefix)
  const WAV_PREFIX = "sounds_flat/"; // 결과적으로 WAV URL은: sounds_flat + (definition.name) + ".wav"

  // ====== 유틸 ======
  const $ = (sel) => document.querySelector(sel);
  const listEl = $("#list");
  const countEl = $("#count");
  const pagerEl = $("#pager");
  const searchEl = $("#search");

  let events = [];       // [{label, variants: [wavUrl, ...]}]
  let filtered = [];     // 검색/정렬 후
  let page = 1;

  function paginate(arr, pageSize, pageNum) {
    const start = (pageNum - 1) * pageSize;
    return arr.slice(start, start + pageSize);
  }

  function renderPager() {
    const total = filtered.length;
    const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
    page = Math.min(page, totalPages);

    pagerEl.innerHTML = "";
    const mkBtn = (txt, disabled, onClick) => {
      const b = document.createElement("button");
      b.textContent = txt;
      if (disabled) b.disabled = true;
      if (onClick) b.addEventListener("click", onClick);
      return b;
    };
    pagerEl.appendChild(mkBtn("⟨ 이전", page <= 1, () => { page--; render(); }));
    const label = document.createElement("span");
    label.className = "small";
    label.textContent = `페이지 ${page} / ${totalPages}`;
    pagerEl.appendChild(label);
    pagerEl.appendChild(mkBtn("다음 ⟩", page >= totalPages, () => { page++; render(); }));
  }

  function createCard(ev) {
    const card = document.createElement("div");
    card.className = "card";

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = ev.label; // minecraft: 접두사 없는 이벤트 이름
    card.appendChild(title);

    const row = document.createElement("div");
    row.className = "row";

    const playBtn = document.createElement("button");
    playBtn.textContent = "▶ 재생";
    row.appendChild(playBtn);

    const stopBtn = document.createElement("button");
    stopBtn.textContent = "■ 정지";
    row.appendChild(stopBtn);

    const pitchWrap = document.createElement("div");
    pitchWrap.className = "row";
    const pitchLabel = document.createElement("span");
    pitchLabel.className = "small";
    pitchLabel.textContent = "피치: ";
    const range = document.createElement("input");
    range.className = "range";
    range.type = "range";
    range.min = "0.1";
    range.max = "2.0";
    range.step = "0.1";
    range.value = "1.0";
    const pv = document.createElement("span");
    pv.className = "small";
    pv.textContent = "1.0";
    pitchWrap.appendChild(pitchLabel);
    pitchWrap.appendChild(range);
    pitchWrap.appendChild(pv);

    card.appendChild(row);
    card.appendChild(pitchWrap);

    // 오디오 엘리먼트는 필요할 때만(src 교체 후 재생)
    const audio = new Audio();
    audio.preload = "none";
    // 재생 속도 = 피치
    range.addEventListener("input", () => {
      pv.textContent = range.value;
      audio.playbackRate = parseFloat(range.value);
    });

    playBtn.addEventListener("click", async () => {
      try {
        // 변종 중 하나를 선택 (가급적 랜덤)
        const choice = ev.variants[Math.floor(Math.random() * ev.variants.length)] || ev.variants[0];
        if (!choice) return;
        // 동일 소스 연속 재생 시 로딩 스킵용
        if (audio.src !== (location.origin + "/" + choice) && audio.src !== new URL(choice, location.href).href) {
          audio.src = choice;
        }
        audio.playbackRate = parseFloat(range.value);
        await audio.play();
      } catch (e) {
        console.error("재생 실패:", e);
        alert("재생에 실패했어요. 파일 경로나 브라우저 정책을 확인해 주세요.");
      }
    });

    stopBtn.addEventListener("click", () => {
      audio.pause();
      audio.currentTime = 0;
    });

    return card;
  }

  function render() {
    // 검색
    const q = (searchEl.value || "").trim().toLowerCase();
    filtered = events.filter(ev => !q || ev.label.toLowerCase().includes(q));

    // 정렬 (이름 오름차순)
    filtered.sort((a, b) => a.label.localeCompare(b.label, 'en'));

    countEl.textContent = `총 ${filtered.length}개 이벤트`;
    renderPager();

    // 페이지
    const pageItems = paginate(filtered, PAGE_SIZE, page);
    listEl.innerHTML = "";
    pageItems.forEach(ev => listEl.appendChild(createCard(ev)));
  }

  searchEl.addEventListener("input", () => { page = 1; render(); });

  // ====== sound_definitions 로드 & 변환 ======
  async function loadDefinitions() {
    // .json → 실패하면 .txt 순서로 시도
    let raw;
    let lastErr;
    for (const url of DEF_URLS) {
      try {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(res.status + " " + res.statusText);
        raw = await res.text();
        // 비어있지 않으면 파싱 시도
        const data = JSON.parse(raw);
        return data;
      } catch (e) {
        lastErr = e;
        // 다음 후보 시도
      }
    }
    throw lastErr || new Error("sound_definitions 파일을 불러오지 못했습니다.");
  }

  function normalizeSoundEntry(entry) {
    // entry는 문자열 또는 { name: "sounds/...", ... }
    if (typeof entry === "string") return entry;
    if (entry && typeof entry === "object" && entry.name) return entry.name;
    return null;
  }

  function buildEvents(defJson) {
    // defJson 구조: { format_version, sound_definitions: { "<label>": { sounds: [ ... ] }, ... } }
    const defs = defJson && (defJson.sound_definitions || defJson);
    const out = [];
    for (const [label, def] of Object.entries(defs)) {
      const arr = (def && def.sounds) || [];
      const variants = [];
      for (const ent of arr) {
        const name = normalizeSoundEntry(ent);
        if (!name) continue;
        // 실제 wav 경로 만들기: sounds_flat/ + name + ".wav"
        // 예) name="sounds/block/loom/take_result1" → "sounds_flat/sounds/block/loom/take_result1.wav"
        const wav = WAV_PREFIX + name + ".wav";
        variants.push(wav);
      }
      // 변종이 하나도 없으면 표시 스킵(재생 불가)
      if (variants.length > 0) {
        // minecraft: 접두사는 원래 definitions key엔 거의 없지만 혹시 몰라 제거
        const niceLabel = label.startsWith("minecraft:") ? label.slice("minecraft:".length) : label;
        out.push({ label: niceLabel, variants });
      }
    }
    return out;
  }

  (async function init() {
    try {
      const def = await loadDefinitions();
      events = buildEvents(def);
      render();
    } catch (e) {
      console.error(e);
      alert("sound_definitions 로드에 실패했어요. 파일이 루트에 있고 JSON형식인지 확인해 주세요.");
    }
  })();
  </script>
</body>
</html>
