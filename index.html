<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Playsound 리스트</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans KR', sans-serif; margin: 0; }
  header { padding: 14px 16px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: #fff; }
  h1 { margin: 0 0 8px; font-size: 22px; }
  .toolbar { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
  .toolbar input[type="search"]{
    flex: 1 1 320px; padding: 10px 12px; border: 1px solid #ccc; border-radius: 10px; outline: none;
  }
  .count { opacity: .75; font-size: 14px; white-space: nowrap; }
  main { padding: 14px 12px 60px; }
  .card {
    border: 1px solid #ddd; border-radius: 14px; padding: 14px; margin: 10px 0;
    background: #fafafa;
  }
  .title { font-weight: 700; margin-bottom: 10px; word-break: break-all; }
  .row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
  button {
    padding: 8px 12px; border-radius: 10px; border: 1px solid #bbb; background: #fff; cursor: pointer;
  }
  button:disabled{ opacity:.5; cursor: not-allowed; }
  .slider { display: grid; grid-template-columns: auto 1fr auto; gap: 8px; align-items: center; width: 100%; }
  input[type="range"]{ width: 100%; }
  .pagination { display: flex; gap: 8px; align-items: center; padding: 8px 16px; }
  .muted { opacity: .7; }
  .hidden { display: none !important; }
</style>
</head>
<body>
<header>
  <h1>Playsound 리스트</h1>
  <div class="toolbar">
    <input id="q" type="search" placeholder="이벤트 이름 검색 (예: beacon.power, ui.loom …)" />
    <span class="count"><span id="total">0</span>개 이벤트</span>
    <span class="count muted">페이지당 100개</span>
  </div>
  <div class="pagination">
    <button id="prev">◀ 이전</button>
    <button id="next">다음 ▶</button>
    <span class="muted" id="pageInfo"></span>
    <button id="reload" style="margin-left:auto;">manifest 다시 불러오기</button>
  </div>
</header>

<main>
  <div id="list"></div>
</main>

<script>
(() => {
  // ====== 설정 ======
  const PAGE_SIZE = 100;

  // ====== 상태 ======
  let manifestUrlUsed = null;
  let allItems = [];     // {name, url}
  let filtered = [];     // 검색 필터된 배열
  let page = 1;          // 1-based
  const cache = new Map(); // url -> {buffer}

  // WebAudio
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // ====== 도우미 ======
  function absoluteFromManifest(rel) {
    try {
      // manifest가 놓인 페이지의 디렉터리를 기준으로 만듦
      const base = manifestUrlUsed ?? location.href;
      const baseDir = base.replace(/manifest\.json.*$/i, '');

      // manifest의 url이 이미 "sounds_flat/..."를 포함하는 구조라면
      // 페이지 기준으로 다시 붙일 때 중복이 생김 → 선제적으로 제거
      const relFixed = rel.replace(/^sounds_flat\//, '');

      // 항상 pages 루트에서 sounds_flat를 기준으로 만들기
      return new URL('sounds_flat/' + relFixed, baseDir).href;
    } catch (e) {
      // 실패 시 대충 보정
      return rel.startsWith('/') ? rel : '/' + rel;
    }
  }

  // 파일 경로를 표시용 이름으로 정규화
  function niceNameFromUrl(u) {
    try {
      const p = new URL(u).pathname
        .replace(/^\/+/, '')
        .replace(/\.wav$/i, '');
      // .../sounds_flat/<path> → <path>
      const idx = p.toLowerCase().indexOf('sounds_flat/');
      const sub = idx >= 0 ? p.slice(idx + 'sounds_flat/'.length) : p;
      // 슬래시 → 점
      return sub.split('/').filter(Boolean).join('.');
    } catch {
      return u;
    }
  }

  function paginate(arr, p, size) {
    const start = (p-1) * size;
    return arr.slice(start, start + size);
  }

  function setPage(p) {
    const totalPages = Math.max(1, Math.ceil(filtered.length / PAGE_SIZE));
    page = Math.min(Math.max(1, p), totalPages);
    render();
  }

  function info(msg, err) {
    alert(msg + (err ? '\n\n원인: ' + (err.message || String(err)) : ''));
  }

  // ====== 렌더링 ======
  const $list = document.getElementById('list');
  const $q = document.getElementById('q');
  const $total = document.getElementById('total');
  const $prev = document.getElementById('prev');
  const $next = document.getElementById('next');
  const $pageInfo = document.getElementById('pageInfo');
  const $reload = document.getElementById('reload');

  function render() {
    $total.textContent = filtered.length.toLocaleString();
    const totalPages = Math.max(1, Math.ceil(filtered.length / PAGE_SIZE));
    $pageInfo.textContent = `총 ${totalPages} 페이지 / 현재 ${page} 페이지`;
    $prev.disabled = page <= 1;
    $next.disabled = page >= totalPages;

    const rows = paginate(filtered, page, PAGE_SIZE);

    $list.innerHTML = '';
    for (const it of rows) {
      const card = document.createElement('div');
      card.className = 'card';

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = it.name;

      const row = document.createElement('div');
      row.className = 'row';

      const playBtn = document.createElement('button');
      playBtn.textContent = '▶ 재생';
      const stopBtn = document.createElement('button');
      stopBtn.textContent = '■ 정지';

      // 피치 슬라이더
      const sliderWrap = document.createElement('div');
      sliderWrap.className = 'slider';
      const pitchLabel = document.createElement('span');
      pitchLabel.textContent = '피치:';
      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0.1';
      range.max = '2.0';
      range.step = '0.1';
      range.value = '1.0';
      const val = document.createElement('span');
      val.textContent = '1.0';

      range.addEventListener('input', () => {
        val.textContent = Number(range.value).toFixed(1);
      });

      sliderWrap.append(pitchLabel, range, val);

      row.append(playBtn, stopBtn);
      card.append(title, row, document.createElement('div'), sliderWrap);
      $list.append(card);

      // 재생/정지 로직
      let currentNode = null;

      async function ensureBuffer(url) {
        if (cache.has(url)) return cache.get(url);
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) throw new Error(`파일 접근 실패 (HTTP ${res.status})`);
        const ab = await res.arrayBuffer();
        const buffer = await audioCtx.decodeAudioData(ab);
        const entry = { buffer };
        cache.set(url, entry);
        return entry;
      }

      playBtn.addEventListener('click', async () => {
        try {
          // 여러 번 눌렀을 때 기존 소스 정지
          if (currentNode) {
            try { currentNode.stop(); } catch {}
            currentNode.disconnect();
            currentNode = null;
          }
          const { buffer } = await ensureBuffer(it.url);
          const src = audioCtx.createBufferSource();
          src.buffer = buffer;
          src.playbackRate.value = Number(range.value);
          src.connect(audioCtx.destination);
          src.start();
          currentNode = src;
          src.onended = () => { currentNode = null; };
        } catch (e) {
          info('재생에 실패했어요. 파일 경로나 브라우저 정책을 확인해 주세요.', e);
        }
      });

      stopBtn.addEventListener('click', () => {
        if (currentNode) {
          try { currentNode.stop(); } catch {}
          currentNode.disconnect();
          currentNode = null;
        }
      });
    }
  }

  function applyFilter() {
    const t = $q.value.trim().toLowerCase();
    if (!t) filtered = allItems.slice();
    else filtered = allItems.filter(x => x.name.toLowerCase().includes(t));
    setPage(1);
  }

  $q.addEventListener('input', () => {
    // 즉시 필터 반영
    applyFilter();
  });

  $prev.addEventListener('click', () => setPage(page - 1));
  $next.addEventListener('click', () => setPage(page + 1));
  $reload.addEventListener('click', () => loadManifest(true));

  // ====== manifest 로딩 ======
  async function loadManifest(force = false) {
    try {
      // pages 루트에서 고정 경로로 시도
      const fixed = new URL('./sounds_flat/manifest.json', location.href).href;
      let url = fixed;

      if (!force) {
        // 혹시 캐시된 게 있으면 유지
        url = manifestUrlUsed || fixed;
      }

      const res = await fetch(url, { mode: 'cors', cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      manifestUrlUsed = url;

      const entries = Array.isArray(data?.entries) ? data.entries : [];
      // manifest의 url은 보통 "sounds_flat/xxx/yyy.wav"
      // → 페이지 기준 절대 경로로 보정
      allItems = entries.map(e => {
        const abs = absoluteFromManifest(String(e.url || ''));
        const name = niceNameFromUrl(abs);
        return { name, url: abs };
      });

      applyFilter();
    } catch (e) {
      info('manifest 로드 실패', e);
    }
  }

  // 초기화
  loadManifest();
})();
</script>
</body>
</html>
